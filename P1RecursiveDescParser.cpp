#include <cstdlib>
#include <vector>
#include <string>
#include <iostream>
#include <fstream>
#include <numeric>
using namespace std;

// function parses the program
string ParseProg(bool token, string lexeme) {
	string program;
	if (lexeme.find("(keyword ident)")) token = true;
	else if (lexeme.find("{ declares assign}")) token = true;
	else if (lexeme.find("keyword ident")) token = true;
	else token = false;
	
	if (token == true) program = "<keyword> <ident> (<keyword><ident>) { <declares> <assign>}";
	return program;
}

// function parses the declaration
string ParseDeclares(bool token, string lexeme) {
	string declares;
	if (lexeme.find("<keyword> <ident> ;")) token = true;
	else token = false;
	if (token == true) declares = "<keyword> <ident> ;\n			|   <keyword> <ident> ; <declares>";
	return declares;
}

// function parses the assignment	
string ParseAssignment(bool token, string lexeme) {
	string assign;
	if (lexeme.find("<ident> = <expr>;")) token = true;
	else token = false;
	if (token == true) assign = "<ident> = <expr>;";
	return assign;
}

// function adds operator symbols to an array
vector<string> exprSymbol(vector<string>& expressions) {
	int expressionsSize = expressions.size();
	for (int i = 0; i < expressionsSize; i++) {
		// loop through array until i = expressionsSize and add "|" until the last element
		// if there are more than 1 symbols, add "|" in between operators
		if (expressionsSize > 1 && i < expressionsSize - 1) expressions.push_back("|");
	}
	return expressions;
}

// function parses the expression	
string ParseExpression(bool token, string lexeme) {
	string expr;
	vector<string> expressions;
	if (lexeme.find("+") && expressions.size() == 0) {
		expressions.push_back("+");
		token = true;
	}
	else if (lexeme.find("-") && expressions.size() == 0) {
		expressions.push_back("-");
		token = true;
	}
	else if (lexeme.find("*") && expressions.size() == 0) {
		expressions.push_back("*");
		token = true;
	}
	else if (lexeme.find("/") && expressions.size() == 0) {
		expressions.push_back("/");
		token = true;
	}
	else token = false;
	
	if (token == true) {
		// if true accumulate the expressions
		expr = "{" + accumulate(expressions.begin(), expressions.end(), expr) + "}\n			|	<ident>";
	}
	return expr;
}

// function adds keyword to an array
vector<string> AddKeyword(vector<string>& keywords, string keyword) {
	int k = keywords.size();
	
	// loop until the last element in the array
	// insert " | " after each element
	for (int i = 0; i < k - 1; i++) {
		if (k > 1) keyword.insert(i, " | ");
	}
	
	return keywords;
}

// function parses the keyword
string ParseKeyword(bool token, string lexeme) {
	string keyword;
	vector<string> keywords;
		
	if (lexeme.find("float") || lexeme.find("void") || lexeme.find("int") || lexeme.find("string") || lexeme.find("bool")) token = true;
	else token = false;
	
	if (token == true && lexeme.find("float")) {
		keyword = "float";
		keywords.push_back("float");
	}
	else if (token == true && lexeme.find("void")) {
		keyword = "void";
		keywords.push_back("void");
	}
	else if (token == true && lexeme.find("int")) {
		keyword = "int";
		keywords.push_back("int");
	}
	else if (token == true && lexeme.find("string")) {
		keyword = "string";
		keywords.push_back("string");
	}
	else if (token == true && lexeme.find("bool")) {
		keyword = "bool";
		keywords.push_back("bool");
	}
	return keyword;
}

// parses ident
string ParseIdent(bool token, string lexeme) {
	string ident;
	if(!lexeme.empty()) token = true;
	else token = false;
	if(token == true) ident = lexeme;
	if(ident.length() > 1) ident += " | "; // add separator in between each element
	return lexeme;
}

// builds the parser in BNF form and returns related information
string RecursiveDescendingParser(string lexeme) {
	string program, expr, declares, assign, keyword, ident, syntaxError = "", notBNF;
	bool token = false;
	vector<string> strArr;
	int errorCount = 0;
	
	// BNF form
	program = "<program> -> " + ParseProg(token, lexeme);
	declares = "<declares> -> " + ParseDeclares(token, lexeme);
	assign = "<assign> -> " + ParseAssignment(token, lexeme);
	expr = "<expr> -> " + ParseExpression(token, lexeme);
	keyword = "<keyword> -> " + ParseKeyword(token, lexeme);
	ident = "<ident> -> " + ParseIdent(token, lexeme);
	
	// push BNF to a string vector
	strArr.push_back(program);
	strArr.push_back(declares);
	strArr.push_back(assign);
	strArr.push_back(expr);
	strArr.push_back(keyword);
	strArr.push_back(ident);
	
	for (int i = 0; i < strArr.size(); i++) {
		// if a string, array vector has syntax errors, add it to the counter
		if (strArr[i] == syntaxError) errorCount++;
	}
	
	// display the number of syntax errors
	cout << "Number of Syntax Errors: " << errorCount << endl;
	
	// if true return "The try program is generated by BNF grammar for Try Program" and display BNF
	if (token == true) {
		cout << program << endl;
		cout << declares << endl;
		cout << assign << endl;
		cout << expr << endl;
		cout << keyword << endl;
		cout << ident << endl;
		return "The try program is generated by BNF grammar for Try Program";
	}
	else {
		//otherwise find the first syntax error and return it
		for (int i = 0; i < strArr.size(); i++) {
			if (strArr[i] == program && (syntaxError != declares && syntaxError != assign && syntaxError != expr && syntaxError != keyword && syntaxError != ident)) {
				// if program contains a syntax error before declares, assign, expr, keyword, or ident,
				// line 1 contains the first syntax error
				syntaxError = program;
			}
			else if (strArr[i] == declares && (syntaxError != assign && syntaxError != expr && syntaxError != keyword && syntaxError != ident)) {
				syntaxError = declares;
			}
			else if (strArr[i] == assign && (syntaxError != expr && syntaxError != keyword && syntaxError != ident)) {
				syntaxError = assign;
			}
			else if (strArr[i] == expr && (syntaxError != keyword && syntaxError != ident)) syntaxError = expr; 
			else if (strArr[i] == keyword && syntaxError != ident) syntaxError = keyword;
			else syntaxError = ident;
		}
		notBNF = "The first syntax error is " + syntaxError;
		return notBNF;
	}
}

int main() {
	string input;
	string input2;
	string lexeme = "";
    
    //import from the text file
    ifstream inputFile("tryInput.txt");
    ifstream inputFile2("tryInput2.txt");
    
    // read the text file
    getline(inputFile, input);
    getline(inputFile2, input2);


    // output an error message if the text file cannot open
    if (!inputFile && !inputFile2) {
        cout << "ERROR can't open input file." << endl;
       
    }
    
    // displays Parser to the Output
    else {
    	cout << "Try File 1" << endl;
        cout << RecursiveDescendingParser(lexeme) << endl;
        
        cout << "Try File 2" << endl;
        cout << RecursiveDescendingParser(lexeme) << endl;

        return 0;
    }
}

